
![080317_bug.png](http://zhouhao-blog.oss-cn-shanghai.aliyuncs.com/articles/8de959d522b108e54e0acf6a39e57dab.png)

+ [看雪](https://bbs.pediy.com/)
+ [吾爱破解](https://www.52pojie.cn/)


## Windows 中的文件类型

> 可执行文件与不可执行文件,分类是怎么来的?

+ windows操作系统
  + 可执行文件: `windows操作系统中有一些文件是原生就支持windows环境的,
  + PE:
    + 一种代码结构,是windows定义的固定格式

+ **`exe,dll,sys` ,这三类就是能在原生 `Windows` 系统环境下就能直接运行的文件**
  + <font color='red' face=Monaco size=3>通常情况下我们运行 `dll` 是通过 `rundll32 xxx.dll`</font> 而这个方式运行其实是比较特殊的，`rundll32` 其实是系统内额外的一个组件，正常情况下我们运行 `dll` 都是通过 `exe` 文件来调用相关的 `dll` 

+ **`msi,zip,iso,rar` 这些都不是可执行文件，都是类似压缩形式的文件**
  + `msi` 是 Windows 系统下安装格式的文件
+ **`bat,py` 这些形式的脚本文件也不是可执行文件**
  + 如 `python xxx.py` 其实运行的是 `python` 这个解释器,`python` 这个解释器才是可执行文件。
  + `xxx.bat` 也是一样的，它运行的是 `cmd.exe`



## windows下运行代码的基本过程

内存颗粒其实就相当于有好多个小钢珠,而传输二进制时,遇到1就通高一点电流,0就低一点电流,而钢珠会因为电流的不同而发生不同的形变,从而保留了数据

```bash
msfvenom
```


3. windows下恶意代码的常见类型和危害

## 常见的恶意代码类型:

### 木马

+ **木马特点:**
  + <font color='red' face=Monaco size=3>一定会有通信模块</font> 
  + 功能模块上的执行一定是针对性的
+ 举例: 如果我们现在想下载目标机器上的一个文件 基本思路是:
  + 运行exe --> 找文件 --> 上传文件 
  + 而木马则是当 XXX 触发时 执行 XXX

<font color='red' face=Monaco size=3>而只有通信部分，功能模块后面通过通信模块传输到目标机器上面，这个模式叫 `stageless`</font>

在 `cs` 里生成木马，也是有两个选项 `exe/exe(s)` 而这个 s 就代表我们要生成 `stageless` 模式的木马


### 病毒
<font color='red' face=Monaco size=3>破坏原有计算机的环境</font>

勒索病毒:破坏原本计算机的文件环境 `xxx.exe --> xxx.jiami`
1. 识别环境
2. 修改环境
3. 还原环境(大部分有) 勒索软件...

如果勒索软件有通信功能 <font color='red' face=Monaco size=3>代表它有解密的可能性</font> 

**特点: 绝大部分有密码学相关的东西**

密钥的实现:
+ 触发恶意代码的时间
+ 用户名称
+ 操作系统内核版本

本地: --> 简单,容易被破解

生成时间
随机数

---
### 恶意行为

<font color='red' face=Monaco size=3>蠕虫,捆绑与挖矿算不算一个单独的恶意代码类型?</font> 




他们只能算是一种行为


CIA (完整性，可用性，机密性)

+ 什么叫恶意行为?
  + 所有触发不符合我们预期结果的行为都叫恶意行为
+ 常见的恶意行为有哪些:
  + 破坏环境(文件,操作系统)
  + 计算机相关的 (开机,关机)
  + 信息被泄露
  + 信息被修改

`hack_browse_data.exe` 获取浏览器信息
[Download Link](https://github.com/moonD4rk/HackBrowserData/releases)





一些关于恶意样本的网站:
+ [微步云](https://s.threatbook.cn/)
+ [Triage](https://tria.ge/)
+ [吾爱破解](https://www.52pojie.cn/forum-32-1.html) 
+ [any.run](https://any.run/)


```c
#include <windows.h>
// 直接可以调用windows默认提供的dll
// 不能调用所有的dll 如 ntdll.dll windows有一部分不开源的函数保存在这个dll里面
// 不能调用自己写的dll

GetProcAddress
// 可以调用所有的
// 可以调用自己的,但是有条件: 这个自己的dll必须在操作系统中提前被使用

LoadLibrary
// 可以调用所有的
// 可以调用自己的
// 不能够调用已经运行的函数地址

```

静态链接
```cpp
#pragma comment (lib,"..//Debug//foo.lib")
```

> 动态链接和静态链接的区别

+ 动态: 在第58行用到了 api 函数才在这里开始导入这个函数
+ 静态: 我不管用不用,导进来再说


![Snipaste_20220410_184020.png](http://zhouhao-blog.oss-cn-shanghai.aliyuncs.com/articles/7403d67b93776564ef0b57f0d5612684.png)



![Snipaste_20220410_183620.png](http://zhouhao-blog.oss-cn-shanghai.aliyuncs.com/articles/0fa8bbf90859948a436ff4b84e7131e8.png)


