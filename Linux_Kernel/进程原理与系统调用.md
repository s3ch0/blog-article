- [ ] **为什么要学习Linux内核？**
+ 提高研发出高水平软件
+ 开发自己的操作系统
+ 有助于计算机科学领域研究
+ Linux系统性能优化




## Linux内核源码目录结构
> **Linux 内核特性**

1. Linux内核的组织形式为整体式结构
2. Linux进程调度方式简单而高效
3. Linux支持内核线程 (守护进程)
4. Linux支持多种平台的虚拟内存管理
5. **Linux内核另一个独具特色的部分是虚拟文件系统 （VFS, Virtual File System）**
6. Linux模块机制使得内核保持独立而又非常容易扩充
7. 增加系统调用主要是满足特殊需求
8. Linux 内核网络模块使用面向对象的设计思想架(支持多种协议，多种网卡驱动程序等)

Linux 内核在系统中的位置
	Linux 内核并不是孤立，要把它放到整个系统中去研究更容易理解，如下图所示内核在操作系统中的位置


系统调用本身也是由若干条指令构成的过程，实现一些特定的服务，但它与一般过程不同区别在于：**系统调用是运行在内核态 ,而一般过程运行在用户态**

> 内核实际是抽象的资源操作到具体硬件操作细节之间的接口

![](http://zhouhao-blog.oss-cn-shanghai.aliyuncs.com/blog/进程原理与系统调用.assets/2022-07-02_08-37.png)
Linux 内核各子系统之间的关系


+ 进程调度:控制着进程对 CPU 的访问操作
+ 内存管理(MM):允许多个进程安全地共享主存区域
+ 虚拟文件系统(VFS):分为设备驱动程序和逻辑文件系统
+ 网络管理: 提供对各种网络标准协议的存取和网络硬件的支持
+ 进程间通信: 支持进程间各种通信机制

![](http://zhouhao-blog.oss-cn-shanghai.aliyuncs.com/blog/进程原理与系统调用.assets/Snipaste_2022-07-02_09-46-56.png)
### Linux 内核源码组织
**Linux 内核源码结构 (version: 5.6.18)**

为更好的深入掌握Linux的实现机制,我们还必须阅读Linux的内核源码。Linux内核源代码版本比较多， <font color="red" face=Monaco size=3>  对于不同的内核版本，系统调用一般是相同的。新版本也许会增加一些新的系统调用。大多数情况下，设备文件仍然相同</font> 而另一方面，版本之间的内部接口有所变化。


> Linux 内核目录结构


+ `arch`:不同平台体系结构的相关代码
+ `block`:块设备驱动
+ `certs`:与认证签名相关代码
+ `crypto`: 内核常用压缩算法，常用加密算法等等源代码
+ `Documentation`:描述模块功能和协议规范代码
+ `drivers`:驱动程序 (USB总线，PCI总线，显示，网卡，蓝牙等)
+ `fs`:虚拟文件系统(VFS) 代码
+ `include`: 内核源码依赖的绝大部分头文件
+ `init`: 内核初始化代码,直接关联到内存各个组件入口
+ `ipc`: 进程间通信实现，(信号量，共享内存等等)
+ `kernel`: 内核核心代码，包括进程管理，IRQ等
+ `lib`: C 标准库子集
+ `licenses` : Linux 内核根据 licenses/preferred/GPL-2.0 中提供GNU通用公共许可证版本2
+ `mm` : 内存管理的相关实现
+ `net` : 网络协议代码(如TCP,WIFI，IPv6等)
+ `samples`: 内核实例代码
+ `scripts`: 编译和配置内核所需要的脚本
+ `security`: 内核安全模块相关的代码
+ `sound`: 声卡驱动源码
+ `tools`: 与内核交互所需要的工具源码
+ `usr`: 用户打包和压缩内核的实现的源码
+ `virt`: `/kvm` 虚拟化目录相关支持实现

> Linux 内核目录下文件

+ `.clang-format`: 平时开发团队进行合作的时候要注意代码格式的规范化

+ `COPYING`: 许可和授权信息

+ `CREDITS`: 贡献者列表

+ `Kbuild`: 内核设定脚本
+ `Kconfig`: 开发人员配置内核的时候所用到的参数信息等
+ `MAINTAINERS`： 目前维护开发人员列表
+ `Makefile`: 编译内核主要文件
+ `README`: 编译内核的信息



内核代码主要以：`.c` 或 `.h` 作为扩展名的文件

## 进程原理与系统调用

Linux 内核靶进程叫做任务(task) ,进程的虚拟地址空间可划分为用户虚拟地址空间和内核虚拟地址空间，所有进程共享内核虚拟地址空间，每个进程有独立的用户虚拟地址空间

进程有两种特殊的形式：没有用户虚拟地址空间的进程叫内核线程，共享用户虚拟地址空间的进程叫用户线程，共享同一个用户虚拟地址空间的所有用户线程叫线程组

| C语言标准库 | Linux内核  |
|:-:|:-: |
| 包含多个线程的进程 | 线程组  |
| 只有一个线程的进程 | 任务或进程  |
| 线程 | 共享用户虚拟地址空间的进程  |

Linux 通过 ps 命令用于输出当前系统的进程状态。显示瞬间进程的状态，并不是动态连续；

![](http://zhouhao-blog.oss-cn-shanghai.aliyuncs.com/blog/进程原理与系统调用.assets/2022-07-02_15-42.png)
如果我们想对进程进行实时监控我们可以使用 top htop 等命令


### 进程的生命周期

Linux操作系统属于多任务操作系统，系统中的每个进程能够分时复用CPU时间片，通 过有效的进程调度策略实现多任务并行执行。而进程在被CPU调度运行，等待CPU资源分配以 及等待外部事件时会属于不同的状态。

进程之间的状态关系：
+ 创建状态：创建新进程
+ 就绪状态：进程获取可以运作所有资源及准备相关条件
+ 执行状态：进程正在CPU中执行操作
+ 阻塞状态：进程因等待某些资源而被跳出CPU
+ 终止状态：进程消亡

![](http://zhouhao-blog.oss-cn-shanghai.aliyuncs.com/blog/进程原理与系统调用.assets/Snipaste_2022-07-02_16-44-24.png)

运行：该进程此刻正在执行。 
等待：进程能够运行，但没有得到许可，因为CPU分配给另一个进程。调度器可以在 下一次任务切换时选择该进程。 

睡眠：进程正在睡眠无法运行，因为它在等待一个外部事件。调度器无法在下一次任 务切换时选择该进程

Linux 内核提供 API 函数来设置进程的状态

+ `TASK_RUNNING` (运行状态或者就绪状态)
+ `TASK_INTERRUPTIBLE` (可中断睡眠状态,又叫浅睡眠状态)
+ `TASK_UNINTERRUPTIBLE` (不可中断状态,又叫深度睡眠状态) 我们可以通过 ps 命令查看被标记为 D 的状态的进程
+ `__TASK_STOPPED` 终止状态
+ `EXIT_ZOMBIE` 僵尸状态


Linux 内核进程描述符 `task_struct` 数据结构

相关文件路径 : `/include/linux/sched.h`

![](http://zhouhao-blog.oss-cn-shanghai.aliyuncs.com/blog/进程原理与系统调用.assets/2022-07-02_17-18.png)

进程是操作系统调度的一个实体,需要对进程所必须资源做一个抽象化，此抽象化为进程控制块 (PCB Process Control Block) 在linux内核里面采用 task_struct 结构体来描述进程控制块。Linux内核涉及进程和程序所有算法都围绕名为 task_struct 的数据结构而建立操作 


进程优先级
限时进程的优先级比实时进程要高，实时进程的优先级比普通进程要高

![](http://zhouhao-blog.oss-cn-shanghai.aliyuncs.com/blog/进程原理与系统调用.assets/2022-07-02_17-26.png)
+ 限时进程的优先级是 -1
+ 实时进程的优先级 1-99 优先级数值越大,表示优先级越高
+ 普通进程的静态优先级为： 100-139 优先级数值越小，表示优先级越高 <font color="red" face=Monaco size=3> 可通过修改 nice 值改变普通进程的优先级，优先级等于120 加上nice值 </font> 


![](http://zhouhao-blog.oss-cn-shanghai.aliyuncs.com/blog/进程原理与系统调用.assets/Snipaste_2022-07-02_18-04-44.png)

系统调用

`/kernel/fork.c`

![](http://zhouhao-blog.oss-cn-shanghai.aliyuncs.com/blog/进程原理与系统调用.assets/2022-07-02_18-09.png)

![](http://zhouhao-blog.oss-cn-shanghai.aliyuncs.com/blog/进程原理与系统调用.assets/2022-07-02_18-16.png)

![](http://zhouhao-blog.oss-cn-shanghai.aliyuncs.com/blog/进程原理与系统调用.assets/2022-07-02_19-16.png)




![](http://zhouhao-blog.oss-cn-shanghai.aliyuncs.com/blog/进程原理与系统调用.assets/Snipaste_2022-07-02_18-49-54.png)
内核线程内核线程是直接由内核本身启动的进程。内核线程实际上是将内核函数委托给独立的 进程，与系统中其他进程“并行”执行（实际上，也并行于内核自身的执行）。内核线程经常 称之为（内核）守护进程。它们用于执行下列任务.
+ 周期性地将修改的内存页与页来源块设备同步（例如，使用mmap的文件映射）。
+ 如果内存页很少使用，则写入交换区。
+ 管理延时动作（deferred action）。
+ 实现文件系统的事务日志。

内核线程 守护进程
它是独立运行在内核空间的进程，与普通用户进程区别在意内核线程没有独立的进程地址空间。task_struct 数据结构里面有一个成员指针 mm 设置为 NULL ,它只能运行在内核空间.

退出进程
退出进程有两种方式
1. 调用 `exit()` 系统调用或从某个程序主函数返回
2. 另一个方式为被接收到杀死信号或者异常时被终止


进程必须用exit系统调用终止。这使得内核有机会将该进 程使用的资源释放回系统。见kernel/exit.c------>do_exit。简而言之， 该函数的实现就是将各个引用计数器减1，如果引用计数器归0而 没有进程再使用对应的结构，那么将相应的内存区域返还给内存 管理模块。

退出进程

进程主动终止：从main()函数返回链接程序会制动添加到 exit() 系统调用 主动调用 exit() 系统函数
进程被动终止：进程收到一个自己不能处理的信号，进程收到 SIGKILL 等终止信号


