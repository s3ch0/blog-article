
## LFSR

线性反馈移位置寄存器(Linear Feedback Shift Register) (LFSR): 给定前一状态的输出，将该输出的线性函数再用作输入的移位寄存器。


移位寄存器是指: 若干个寄存器排成一行，每个寄存器中都存储着一个二进制数 (0或1). 移位寄存器每次把最右端(末端) 的数字输出，然后整体向右移一位。


反馈移位寄存器: 在移位寄存器向右移位一位后，左边会空出一位，此时可以采用一个反馈函数，将寄存器中已有的某些状态作为反馈函数的输入，经过反馈函数运算，并将运算结果填充到移位寄存器的最左端，这样移位寄存器就有源源不断的输入。


线性反馈移位置寄存器: 反馈函数是线性函数 (只进行简单线性运算的函数) 的反馈移位寄存器。线性运算通常是简单地对某些位祝贺异或，并将异或的结果填充到 LFSR 的最左端.

下图为一种常见的线性反馈移位寄存器，其中 $[\;m_1,m_2,m_3,m_4\;]$ 取值为 0 或 1 ,表示是否为抽头，即该为是否参与运算。其反馈函数为:
$$
f(s_1,s_2,s_3,s_4) = m_4\cdot s_4+m_3 \cdot s_3 + m_2 \cdot s_2 + m_1 \cdot s_1
$$

若取 $m_1,m_4$ 为抽头，则其反馈函数可以化简为:
`+` 为异或
$$
f(s_1,s_2,s_3,s_4) = s_1 + s_4
$$

我们通常把 LFSR 的寄存器个数称为 LSFR 的 <font color="red"> 级数 </font> 

一个 $n$ 级 的 LFSR 最多可以存储 $2^n -1$ 种状态， (LFSR 中的所有状态全为 0 时，其反馈函数的输出也永远是 0 ，输出序列将一直是 0,这种情况是不可用的 )

例如,一个三级的 LFSR 最多可以遍历 `001,010,011,100,101,110,111` 共七种状态。

由于 LFSR 一个 n级的 LFSR 最多可以存储 $2^n -1$ 种状态，因此当 LFSR 移位到一定程度时，一定会出现重复的状态。而相同状态生成的反馈函数结果总是相同的，因此 LFSR 会陷入一种循环， <font color="red"> 即 LFSR 存在周期 </font> 

LFSR 的周期与其反馈函数是有密切关系的，反馈函数决定了 LFSR 的循环序列.

若 LFSR 中的值为 $[\;s_1,s_2,\cdots,s_n\;]$,则第 $n + 1$位的值可以表示为：
$$
s_{n+1} = m_n\cdot s_n + \cdots + m_2\cdot s_2 + m_1 \cdot s_1
$$

此递推关系可以对应一个 <font color="red"> 特征多项式子 </font> 
$$
f(x) = m_n \cdot x^n + \cdots + m_2 \cdot x^2 + m_1 \cdot x + 1
$$


例如对于之前的例子中的 4 级 LFSR,其特征多项式为:
$$
f(x) = x^4 + x + 1
$$


为了能产生足够安全的密钥，通常要求 LFSR 的周期要足够大。

一个 $n$ 级的 LFSR 最多可以存储 $2^n -1$种状态，其最大周期也为 $2^n-1$

<font color="red"> m 序列:</font> 周期为 $2^n - 1$ 的 LFSR所生成的序列

Q: 什么时候能产生最大周期
A: 当特征多项式为本原多项式时。


## 相关利用手法

在已知 LFSR 的反馈函数的前提下，如果对手已知连续 n 位明文和n位密文，则可以计算得出 n 位密钥，即为 LFSR 的一个状态。此时根据反馈函数，即可计算出 LFSR 的全部输出，即全部密钥流，从而破解 LFSR

在未知 LFSR 的反馈函数的前提下，对手依然通过获取连续 2n 位明文和 2n 位密文，计算得出 2n 位密钥 $[\; k_1,k_2,\cdots ,k_n,\cdots,k_{2n} \;]$。这 2n 位 密钥中，蕴含着 LFSR 的 n + 1 种状态，分别为 $[k_1,k_2,\cdots,k_n],[k_2,k_3\cdots,k_{n+1}],\cdots,[k_{n+1},k_{n+2}\cdots,k_{2n}]$

这些状态之间存在者互相递推关系，例如 $k_{n+1}$ 就是由 $[k_1,k_2,\cdots,k_n]$ 计算出来的。一次类推， $k_{n+i}$ 由 $[k_i,k_{i+1},\cdots,k_{i+n-1}]$ 计算得出，从而可以得到 n 个线性方程，构成一个线性方程组


$$
f(x)=\left\{
\begin{aligned}
  k_{n+1} = k_1c_n + k_2c_{n-1} + \cdots + k_nc_1\\
  k_{n+2} = k_2c_n + k_3c_{n-1} + \cdots + k_{n+1}c_1\\
  \cdots\\
  k_{2n} = k_nc_n + k_{n+1}c_{n-1} + \cdots + k_{2n-1}c_i
\end{aligned}
\right.
$$

其中 $C_i$ 为每个抽头的取值，n个方程，n个未知数，可以求出每一个抽头的唯一解，得到反馈函数，从而攻破 LFSR


```python
n=...
k2n = [...]
M = matrix(GF(2),n,n)
for i in range(n):
    for j in range(n):
        M[i,j] = k2n[i+j]

Y = vector(GF(2),n)

for i in range(n):
    Y[i] = k2n[n+i]
C = M.solve_right(Y)
print(C)
```
单纯仅使用 LFSR 来生成密钥流是不安全的，真实世界中一般采用多个 LFSR 相结合，并通过一个聚合函数来计算输出。

但是也有根据线性特征来进行破解的利用手法
