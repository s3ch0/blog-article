## RC4 加密简介

RC4 是一种对称加密算法，所谓对称加密算法是指加密和解密使用相同密钥的加密算法，数据发送方利用密钥将明文经过特殊加密算法处理后，使其变成复杂的加密密文发送出去，接收方收到密文后，如果想解读原文，则需要使用加密用过的密钥及相关算法的逆算法对密文进行解密，才能使其恢复成可读明文。

RC4 算法简单，运行速度快，而且密钥长度是可变的，可变范围为 1-256 字节(8-2048比特) ，生成的密钥流的长度和明文的长度是对应的，密钥流是由密钥和其长度所决定的，加密和解密使用相同的算法，密钥流是由密钥和其长度所决定的。在现在技术支持的前提下，当密钥长度为128比特时，用暴力法搜索密钥已经不太可行，所以能够遇见 RC4 的密钥范围仍然能够在今后相当长的时间里抵御暴力搜索密钥的攻击。实际上，现在也没有找到对于 128bit 密钥长度的 RC4 加密算法的有效攻击方法。

RC4 主要包括了初始算法(KSA) 和加密算法两大部分。

## RC4 加密流程分析

1. 先初始化状态向量S (256个字节，用来作为密钥流生成的种子1) 按照升序，给每个字节赋值 0,1,2,3,4,5,6...,254,255
2. 初始密钥 (由用户输入),长度任意，如果输入长度小于 256 个字节，则进行轮转，直到填满，例如输入密钥是 1,2,3,4,5 那么填入的是 1,2,3,4,5,1,2,3,4,5......
由上述轮转过程得到 256 个字节的向量 T (用来作为密钥流生成的种子2)
3. 最后是根据向量 S 和 T 生成密钥流与明文进行加密

代码通常的结构:

```bash
# 1. 初始化 S 和 T
for i=0 to 255 do
    S[i]=i;
	T[i]=K[ i mod keylen ];
# 2. 初始化排列 S
j=0;
for i=0 to 255 do
    j=( j+S[i] +T[i] ) mod 256;
	swap(S[i],S[j]);
# 3. 产生密钥流，利用密钥流和明文进行加密
i,j=0;
for r=0 to len do // r 为明文长度，r 字节
    i=(i+1) mod 256;
	j=(j+S[i]) mod 256;
	swap(S[i],S[j]);
	t=(S[i],+S[j]) mod 256;
	k[r]=S[t];
	data[r] ^= k[r]; // 加密
```

```python
1011(明文) ^ 1101(密钥流) = 0110(加密后的数据)
a ^ b = c
a = c ^ b
0110 ^ 1101 = 1011
```


## RC4 特征识别

几个关键特征:
<font color="red"> (RC4 我们通常是用加密过程的特征去识别的，之后讲的 AES 等加密算法是存在一些特征值的。) </font>
1. 反编译后可以看见多个循环次数为 256 的循环，以及存在一些 %256 的运算
2. 最后处理输入数据的是异或


## 实际CTF案例

## RC4 常见魔改方法
**由于RC4的加密就是生成密钥流和输入进行异或，所以通过魔改就是添加一些可逆运算**
1.魔改初始算法，可以将 S 盒初始化值并不设置成 0-255, 也可以设置成其它的，也可以在 S 的初始置换过程中添加可逆运算

其实这些都不影响，后面学会动态调试之后可以直接将它 `rc4_init` 算法生成的大小为255的 S盒从内存中取出即可

2. 由于最后加密flag是利用密钥流来单字节加密的，也有人会在这个地方添加一些可逆运算来进行魔改

总之遵循:
```c
end_data = RC4(flag)
flag = RC4(end_data)
```

